use crate::{
    errors::{RpcError, RpcStatus},
    response::{IntoRpcResponse, RpcResponse},
};
use axum::{
    Router,
    body::Body,
    extract::{FromRequestParts, Query, Request, State},
    http::{Method, request::Parts},
    response::IntoResponse,
    routing::any,
};
use indoc::formatdoc;
use serde::{
    Deserialize, Deserializer,
    de::{self},
};
use serde_json::Value;
use specta::{
    TypeCollection,
    datatype::{FunctionResultVariant, reference::Reference},
};
use specta_typescript::{BigIntExportBehavior, Typescript, datatype};
use std::{collections::HashMap, marker::PhantomData, pin::Pin, sync::Arc};

const MAX_BODY_SIZE: usize = 1024 * 1024; // 1 MB

#[derive(Clone, Copy, Debug)]
pub enum RpcType {
    Query,
    Mutation,
}

pub struct RpcMethod<S> {
    pub name: String,
    pub rpc_type: RpcType,
    pub input_type: Option<Reference>,
    pub output_type: Option<Reference>,
    pub handler: Arc<
        dyn Fn(Option<Value>, S, Parts) -> Pin<Box<dyn Future<Output = RpcResponse> + Send>>
            + Send
            + Sync,
    >,
}

pub struct RpcRouter<S = ()> {
    handlers: Arc<HashMap<String, RpcMethod<S>>>,
    type_map: TypeCollection,
    _phantom: PhantomData<S>,
}

impl RpcRouter<()> {
    pub fn new() -> Self {
        Self {
            handlers: Arc::new(HashMap::new()),
            type_map: TypeCollection::default(),
            _phantom: PhantomData,
        }
    }
}

impl<S1: Clone + Send + Sync + 'static> RpcRouter<S1> {
    pub fn for_state<S2: Clone + Send + Sync + 'static>(self) -> RpcRouter<S2> {
        RpcRouter {
            handlers: Arc::new(HashMap::new()),
            type_map: self.type_map,
            _phantom: PhantomData::<S2>,
        }
    }

    pub fn add<F>(mut self, route_handler_wrapper: F) -> Self
    where
        F: FnOnce(&mut TypeCollection) -> RpcMethod<S1>,
    {
        let route_handler = route_handler_wrapper(&mut self.type_map);
        let handlers = Arc::get_mut(&mut self.handlers).unwrap();
        handlers.insert(route_handler.name.clone(), route_handler);
        self
    }

    pub fn write_client(self, _path: &str) -> Result<Self, std::io::Error> {
        #[cfg(debug_assertions)]
        {
            let export_config = Typescript::default()
                .bigint(BigIntExportBehavior::Number)
                .header("")
                .framework_header("");

            let mut router_entries = Vec::new();
            for route in self.handlers.values() {
                let type_method = match route.rpc_type {
                    RpcType::Query => "query",
                    RpcType::Mutation => "mutation",
                };

                let call_error = "{ throw new Error('Router should not be used') }";
                let route_name = &route.name;
                let input_validator = if let Some(input_type) = &route.input_type {
                    let inlined = datatype(
                        &export_config,
                        &FunctionResultVariant::Value(input_type.inner.clone()),
                        &self.type_map,
                    )
                    .unwrap();

                    format!(".input((value): {inlined} => {call_error})")
                } else {
                    String::new()
                };

                let output_validator = if let Some(output_type) = &route.output_type {
                    let inlined = datatype(
                        &export_config,
                        &FunctionResultVariant::Value(output_type.inner.clone()),
                        &self.type_map,
                    )
                    .unwrap();
                    format!(".output((value): {inlined} => {call_error})")
                } else {
                    String::new()
                };

                let output_type = match &route.output_type {
                    Some(output_type) => datatype(
                        &export_config,
                        &FunctionResultVariant::Value(output_type.inner.clone()),
                        &self.type_map,
                    )
                    .unwrap(),
                    None => "void".to_string(),
                };

                let route_func = format!(
                    "{route_name}: publicProcedure{input_validator}{output_validator}.{type_method}((opts): {output_type} => {call_error})",
                );

                router_entries.push(route_func);
            }

            let type_defs = export_config.export(&self.type_map).unwrap();
            let type_defs = type_defs.trim();
            let router_def = formatdoc!(
                "
                /* eslint-disable */
                /* tslint:disable */
                /* Generated by Specta for Juno. DO NOT EDIT */
                import {{ initTRPC }} from '@trpc/server';

                {type_defs}

                const t = initTRPC.create();
                const publicProcedure = t.procedure;
                const appRouter = t.router({{
                    {}
                }});

                export type AppRouter = typeof appRouter;
                ",
                router_entries.join(",\n")
            );

            std::fs::write(_path, router_def)?;
        }

        Ok(self)
    }

    pub fn to_router(self) -> Router<S1> {
        let handlers = self.handlers.clone();
        Router::<S1>::new().route(
            "/{*rpc_method_name}",
            any(move |state: State<S1>, req: Request<Body>| async move {
                let handlers = handlers.clone();
                let name = req.uri().path().trim_start_matches("/").to_string();

                let Some(handler) = handlers.get(&name) else {
                    return RpcError::new(
                        RpcStatus::NotFound,
                        format!("Handler `{}` not found", name),
                    )
                    .into_rpc_response()
                    .into_response();
                };

                let method = req.method().clone();
                let (mut parts, body) = req.into_parts();
                let query = match handler.rpc_type {
                    RpcType::Query => {
                        if method != Method::GET && method != Method::HEAD {
                            return RpcError::new(
                                RpcStatus::MethodNotSupported,
                                format!("Method `{}` not supported for RPC", method),
                            )
                            .into_rpc_response()
                            .into_response();
                        }

                        match Query::<RpcQuery>::from_request_parts(&mut parts, &state).await {
                            Ok(query) => query.0,
                            Err(err) => {
                                return RpcError::new(
                                    RpcStatus::BadRequest,
                                    format!("Invalid input for `{}`: {}", name, err),
                                )
                                .into_rpc_response()
                                .into_response();
                            }
                        }
                    }
                    RpcType::Mutation => {
                        if method != Method::POST {
                            return RpcError::new(
                                RpcStatus::MethodNotSupported,
                                format!("Method `{}` not supported for RPC", method),
                            )
                            .into_rpc_response()
                            .into_response();
                        }

                        let bytes = match axum::body::to_bytes(body, MAX_BODY_SIZE).await {
                            Ok(bytes) => bytes,
                            Err(err) => {
                                return RpcError::new(
                                    RpcStatus::BadRequest,
                                    format!("Failed to read request body: {}", err),
                                )
                                .into_rpc_response()
                                .into_response();
                            }
                        };

                        let input = if bytes.is_empty() {
                            None
                        } else {
                            match serde_json::from_slice::<Value>(&bytes) {
                                Ok(value) => Some(value),
                                Err(err) => {
                                    return RpcError::new(
                                        RpcStatus::BadRequest,
                                        format!("Invalid JSON in request body: {}", err),
                                    )
                                    .into_rpc_response()
                                    .into_response();
                                }
                            }
                        };

                        RpcQuery { batch: None, input }
                    }
                };

                if query.batch.unwrap_or(false) {
                    return RpcError::new(
                        RpcStatus::NotImplemented,
                        "Batch requests are not supported".to_string(),
                    )
                    .into_rpc_response()
                    .into_response();
                }

                let result = (handler.handler)(query.input, state.0, parts).await;
                result.into_response()
            }),
        )
    }
}

#[derive(Deserialize)]
struct RpcQuery {
    #[serde(default, deserialize_with = "deserialize_optional_num_bool")]
    pub batch: Option<bool>,
    #[serde(default, deserialize_with = "deserialize_optional_json_string")]
    pub input: Option<Value>,
}

pub fn deserialize_optional_json_string<'de, D>(deserializer: D) -> Result<Option<Value>, D::Error>
where
    D: Deserializer<'de>,
{
    let opt_str: Option<String> = Option::deserialize(deserializer)?;
    match opt_str {
        None => Ok(None),
        Some(s) if s.is_empty() => Ok(None),
        Some(j) => serde_json::from_str(&j)
            .map_err(de::Error::custom)
            .map(Some),
    }
}

pub fn deserialize_optional_num_bool<'de, D>(deserializer: D) -> Result<Option<bool>, D::Error>
where
    D: Deserializer<'de>,
{
    let value: Option<Value> = Option::deserialize(deserializer)?;
    match value {
        None => Ok(None),
        Some(Value::String(s)) => match s.as_str() {
            "" => Ok(None),
            "true" | "1" => Ok(Some(true)),
            "false" | "0" => Ok(Some(false)),
            _ => Err(de::Error::custom("Expected a bool-ish string")),
        },
        _ => Err(de::Error::custom("Expected a bool-ish string")),
    }
}
